<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Dashboard - Website Access Monitor</title>
    <style>
        /* --- Base Styles --- */
        :root {
            --primary: #4f46e5;
            --primary-hover: #4338ca;
            --secondary: #f3f4f6;
            --text: #1f2937;
            --text-light: #6b7280;
            --danger: #ef4444;
            --success: #10b981;
            --border: #e5e7eb;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        body {
            background-color: #f9fafb;
            color: var(--text);
            line-height: 1.5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* --- Header --- */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .refresh-btn {
            background-color: var(--secondary);
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .refresh-btn:hover {
            background-color: #e5e7eb;
        }

        /* --- Cards --- */
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
        }

        /* --- Search --- */
        .search-container {
            display: flex;
            gap: 10px;
            margin-bottom: 16px;
        }

        .search-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 14px;
        }

        /* --- Table Enhancements --- */
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
            /* Helps enforce column widths */
            margin-bottom: 1.5rem;
            /* Add space below table before pagination */
        }

        th,
        td {
            padding: 12px 10px;
            /* Adjust padding slightly */
            text-align: left;
            border-bottom: 1px solid var(--border);
            /* Default word break for safety, override below */
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Column Specific Styles */
        th:nth-child(1),
        td:nth-child(1) {
            /* Client ID */
            width: 15%;
            min-width: 100px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        th:nth-child(2),
        td:nth-child(2) {
            /* Action Type */
            width: 15%;
            min-width: 100px;
            white-space: nowrap;
        }

        /* === MODIFIED RULE FOR WEBSITE/DESCRIPTION === */
        th:nth-child(3),
        td:nth-child(3) {
            /* Website/Description */
            width: 40%;
            /* Keep defined width */
            white-space: nowrap;
            /* Prevent wrapping to new lines */
            overflow: hidden;
            /* Hide content that overflows */
            text-overflow: ellipsis;
            /* Show ... for hidden content */
            /* Remove word-break and white-space: normal if they were previously here */
        }

        /* === END OF MODIFIED RULE === */

        th:nth-child(4),
        td:nth-child(4) {
            /* Timestamp */
            width: 20%;
            min-width: 160px;
            white-space: nowrap;
        }

        th:nth-child(5),
        td:nth-child(5) {
            /* Status */
            width: 10%;
            min-width: 80px;
            text-align: center;
            white-space: nowrap;
        }

        th {
            font-weight: 500;
            color: var(--text-light);
            font-size: 14px;
        }

        /* Remove border from last row in tbody */
        tbody tr:last-child td {
            border-bottom: none;
        }

        tbody tr:hover {
            background-color: #f9fafb;
        }

        .timestamp {
            color: var(--text-light);
            font-size: 14px;
        }

        /* --- List Management (Blacklist/Whitelist) --- */
        .list-management {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .list-management {
                grid-template-columns: 1fr;
            }
        }

        .list-card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }

        .blacklist {
            border-top: 3px solid var(--danger);
        }

        .whitelist {
            border-top: 3px solid var(--success);
        }

        .url-input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 16px;
        }

        .url-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 14px;
        }

        .add-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        }

        .add-btn:hover {
            background-color: var(--primary-hover);
        }

        .url-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px;
            min-height: 50px;
            /* Ensure it doesn't collapse when empty */
        }

        .url-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid var(--border);
            word-break: break-all;
            /* Break long URLs */
        }

        .url-item:last-child {
            border-bottom: none;
        }

        .remove-btn {
            background-color: transparent;
            border: none;
            color: var(--danger);
            cursor: pointer;
            font-size: 14px;
            padding: 4px;
            /* Easier to click */
            margin-left: 8px;
            /* Space from text */
        }

        /* --- States (Empty, Loading) --- */
        .empty-state {
            text-align: center;
            padding: 20px;
            color: var(--text-light);
            font-size: 14px;
        }

        /* Specific empty state for table body */
        td.empty-state {
            text-align: center;
            padding: 20px;
            color: var(--text-light);
            font-size: 14px;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            width: 100%;
            /* Ensure it takes full width */
            min-height: 50px;
            /* Give it some height */
        }

        .spinner {
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 3px solid var(--primary);
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        /* --- Tabs --- */
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            margin-bottom: 16px;
        }

        .tab {
            padding: 8px 16px;
            cursor: pointer;
            font-weight: 500;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
            /* Overlap border */
        }

        .tab.active {
            border-bottom: 2px solid var(--primary);
            color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* --- Misc --- */
        .last-updated {
            font-size: 12px;
            color: var(--text-light);
            margin-top: 4px;
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 9999px;
            font-size: 12px;
            font-weight: 500;
        }

        .badge-blocked {
            background-color: #fee2e2;
            color: #b91c1c;
        }

        .badge-allowed {
            background-color: #d1fae5;
            color: #065f46;
        }

        /* --- Pagination --- */
        .pagination-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            margin-top: -1rem;
            /* Pull closer to table */
            font-size: 14px;
            color: var(--text-light);
        }

        .pagination-controls button {
            background-color: var(--secondary);
            border: 1px solid var(--border);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            color: var(--text);
            transition: background-color 0.2s ease;
        }

        .pagination-controls button:hover:not(:disabled) {
            background-color: #e5e7eb;
        }

        .pagination-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .page-info {
            margin: 0 15px;
        }

        /* --- Log Container Styles --- */
        #accessTableContainer {
            position: relative;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 8px;
        }

        .end-of-logs {
            text-align: center;
            padding: 15px;
            color: var(--text-light);
            font-size: 14px;
            border-top: 1px solid var(--border);
        }

        .new-logs-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background-color: var(--primary);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            z-index: 100;
            display: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(79, 70, 229, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(79, 70, 229, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(79, 70, 229, 0);
            }
        }

        /* --- Animation --- */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Website Access Monitor</h1>
            <button id="refreshBtn" class="refresh-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 2v6h-6"></path>
                    <path d="M3 12a9 9 0 0 1 15-6.7L21 8"></path>
                    <path d="M3 22v-6h6"></path>
                    <path d="M21 12a9 9 0 0 1-15 6.7L3 16"></path>
                </svg>
                Refresh Data
            </button>
        </header>

        <div class="list-management">
            <div class="list-card blacklist">
                <div class="card-header">
                    <div>
                        <h2 class="card-title">Blacklisted Websites</h2>
                        <div id="blacklistLastUpdated" class="last-updated"></div>
                    </div>
                </div>
                <div class="tabs">
                    <div class="tab active" data-tab="domains">Domains</div>
                    <div class="tab" data-tab="keywords">Keywords</div>
                </div>
                <div class="tab-content active" id="domains-content">
                    <div class="url-input-container">
                        <input type="text" id="domainInput" class="url-input" placeholder="Enter domain to blacklist">
                        <button id="addToDomains" class="add-btn">Add</button>
                    </div>
                    <div class="url-list" id="domainsContainer">
                        <div class="loading">
                            <div class="spinner"></div>
                        </div>
                    </div>
                </div>
                <div class="tab-content" id="keywords-content">
                    <div class="url-input-container">
                        <input type="text" id="keywordInput" class="url-input" placeholder="Enter keyword to blacklist">
                        <button id="addToKeywords" class="add-btn">Add</button>
                    </div>
                    <div class="url-list" id="keywordsContainer">
                        <div class="loading">
                            <div class="spinner"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="list-card whitelist">
                <div class="card-header">
                    <div>
                        <h2 class="card-title">Whitelisted Websites</h2>
                        <div id="whitelistLastUpdated" class="last-updated"></div>
                    </div>
                </div>
                <div class="url-input-container">
                    <input type="text" id="whitelistInput" class="url-input"
                        placeholder="Enter website URL to whitelist">
                    <button id="addToWhitelist" class="add-btn">Add</button>
                </div>
                <div class="url-list" id="whitelistContainer">
                    <div class="loading">
                        <div class="spinner"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Client Website Access Log</h2>
            </div>
            <div class="search-container">
                <input type="text" id="searchInput" class="search-input"
                    placeholder="Search by client ID or website...">
            </div>
            <div id="newLogsIndicator" class="new-logs-indicator">New logs available</div>
            <div id="accessTableContainer">
                <table id="accessTable">
                    <thead>
                        <tr>
                            <th>Client ID</th>
                            <th>Action Type</th>
                            <th>Website/Description</th>
                            <th>Timestamp</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="accessTableBody">
                        <tr>
                            <td colspan="5" class="loading">
                                <div class="spinner"></div>
                            </td>
                        </tr>
                    </tbody>
                </table>
                <div id="loadMoreSpinner" class="loading" style="display: none;">
                    <div class="spinner"></div>
                </div>
                <div id="endOfLogs" class="end-of-logs" style="display: none;">
                    No more log history to fetch
                </div>
            </div>
        </div>
    </div>

    <script>
        var secret='';
        var socketUrl='ws://localhost:3002';
        try{
            // Global variables to store data
            {{data_placeholder}}
        } catch (e) {
            console.log('variables not recieved');
        }

        // WebSocket Connection
        let socket = null;
        // let isConnecting = false;
        let reconnectInterval = 7000; // Reconnect every 7 seconds

        // WebSocket Management
        function connectWebSocket() {
            if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
                console.log('WebSocket already connected or connecting: ', socket.readyState === WebSocket.OPEN, socket.readyState === WebSocket.CONNECTING);
                if (socket.readyState === WebSocket.OPEN){
                    console.log('sending message bcz shows open.');
                    sendWebSocketMessage('4hey is connction really done???????');
                }
                return;
            }
            
            // if (isConnecting) return;
            // isConnecting = true;
            
            try {
                console.log('Connecting to WebSocket server...');
                socket = new WebSocket(socketUrl);
                
                socket.onopen = () => {
                    sendWebSocketMessage('WebSocket connection established, sending auth');
                    // isConnecting = false;
                    sendWebSocketMessage('0'+JSON.stringify({
                        "secret": secret // will be obtained at runtime
                    }))
                    console.log('sent message');
                };
                
                socket.onmessage = (event) => {
                    handleWebSocketMessage(event.data);
                };
                
                socket.onclose = (event) => {
                    console.log('WebSocket connection closed', event.code, event.reason);
                    // isConnecting = false;
                    scheduleReconnect();
                };
                
                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    // isConnecting = false;
                    scheduleReconnect();
                };

            } catch (error) {
                console.error('Error creating WebSocket connection:', error);
                // isConnecting = false;
                scheduleReconnect();
                sendWebSocketMessage('8'+error);
            }
        }
        
        function scheduleReconnect() {
            setTimeout(() => {
                console.log('Attempting to reconnect WebSocket...');
                connectWebSocket();
            }, reconnectInterval);
        }
        
        function sendWebSocketMessage(message) {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                console.log('Cannot send message, WebSocket not connected');
                return false;
            }
            
            try {
                console.log('trying to send this: ', message)
                socket.send(message);
                console.log('message sent')
                return true;
            } catch (error) {
                console.error('Error sending WebSocket message:', error);
                // sendWebSocketMessage('8'+error);
                return false;
            }
        }
        
        function handleWebSocketMessage(data) {
            sendWebSocketMessage("4------ recieved message: "+data);
            try {
                if (typeof data !== 'string'){
                    sendWebSocketMessage('8'+(typeof data));
                    return
                }

                if (data.startsWith('2')){
                    sendWebSocketMessage('3')
                } else if (data.startsWith('4')){
                    console.log('received data: ', data)
                    const message = JSON.parse(data.substring(1));
                    // sendWebSocketMessage(`4 HI received message: ${JSON.stringify(JSON.parse(message.data).res)}`)

                    if (message.type=="all_data"){
                        if (message.for == 'whitelist'){
                            whitelistUrls = message.data?.domains || [];
                            renderWhitelist();
                        } else if (message.for == 'blacklist'){
                            blacklistSettings = message.data;
                            renderBlacklist();
                        } else if (message.for == 'range_log'){
                            sendWebSocketMessage('4 GOT RANGE LOG');
                            const newLogs = message.data || [];
                            logData = [...logData, ...newLogs];
                            if (logOffset===0){
                                renderAccessTable(true);
                            } else {
                                appendOlderLogs(newLogs);
                            }
                            
                            // Hide loading spinner
                            document.getElementById('loadMoreSpinner').style.display = 'none';
                            
                            // Show end of logs message if no more logs
                            if (newLogs.length < logBatchSize) {
                                allLogsLoaded = true;
                                document.getElementById('endOfLogs').style.display = 'block';
                            }
                            isLoadingMore = false;
                        }

                    } else if (message.type === "update") {
                        if (message.for === "log") {
                            // Handle real-time log updates
                            liveUpdated+=1;
                            // sendWebSocketMessage('4got update: '+JSON.parse(message.data).res)
                            handleLiveLogUpdates(JSON.parse(message.data).res || []);
                        } else if (message.for === "settings") {
                            const updatedSettings = JSON.parse(message.data || "{}");
                            if (updatedSettings.type === "blacklist") {
                                blacklistSettings = updatedSettings.data;
                                blacklistLastUpdatedElement.textContent = `Last updated: ${formatTimestamp(blacklistSettings.data.lastUpdated)};`;
                                renderBlacklist();
                            } else if (updatedSettings.type === "whitelist") {
                                whitelistUrls = updatedSettings.data.domains || [];
                                whitelistLastUpdatedElement.textContent = `Last updated: ${formatTimestamp(updatedSettings.settings.data.lastUpdated)};`;
                                renderWhitelist();
                            }
                        }
                    }
                } else if (data.startsWith('6')){
                    sendWebSocketMessage('4'+JSON.stringify({
                        "type": "whitelist",
                    }))
                    sendWebSocketMessage('4'+JSON.stringify({
                        "type": "blacklist",
                    }))
                    // Request initial batch of logs
                    requestLogs(0, logBatchSize);
                }
            } catch (error) {
                // Handle as plain text if not JSON
                console.log('Received WebSocket text message:', data);
                sendWebSocketMessage('8'+error);
            }
        }
        
        function closeWebSocket() {
            if (socket) {
                socket.close();
                socket = null;
            }
        }

        connectWebSocket();
        scheduleReconnect();

        // --- Log Management Variables ---
        let logData = [];
        let blacklistSettings = null;
        let whitelistUrls = []; 
        let logOffset = 0;
        let logBatchSize = 100; // Number of logs to fetch per batch
        let isLoadingMore = false;
        let allLogsLoaded = false;
        let isAtBottom = true; // Track if user is at the bottom of the log
        let hasNewLogs = false; // Track if new logs are available while user is scrolled away
        let userScrolled = false; // Track if user has manually scrolled
        let liveUpdated = 0;

        // --- DOM elements ---
        const accessTableBody = document.getElementById('accessTableBody');
        const accessTableContainer = document.getElementById('accessTableContainer');
        const searchInput = document.getElementById('searchInput');
        const refreshBtn = document.getElementById('refreshBtn');
        const domainInput = document.getElementById('domainInput');
        const keywordInput = document.getElementById('keywordInput');
        const whitelistInput = document.getElementById('whitelistInput');
        const addToDomainsBtn = document.getElementById('addToDomains');
        const addToKeywordsBtn = document.getElementById('addToKeywords');
        const addToWhitelistBtn = document.getElementById('addToWhitelist');
        const domainsContainer = document.getElementById('domainsContainer');
        const keywordsContainer = document.getElementById('keywordsContainer');
        const whitelistContainer = document.getElementById('whitelistContainer');
        const blacklistLastUpdatedElement = document.getElementById('blacklistLastUpdated');
        const whitelistLastUpdatedElement = document.getElementById('whitelistLastUpdated');
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const loadMoreSpinner = document.getElementById('loadMoreSpinner');
        const endOfLogs = document.getElementById('endOfLogs');
        const newLogsIndicator = document.getElementById('newLogsIndicator');

        // --- Utility Functions ---

        // Format timestamp
        function formatTimestamp(timestamp) {
            if (!timestamp) return '-';
            try {
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) {
                    console.warn('Invalid timestamp received:', timestamp);
                    return 'Invalid Date';
                }
                return date.toLocaleString(undefined, {
                    year: 'numeric', month: 'short', day: 'numeric',
                    hour: 'numeric', minute: '2-digit', second: '2-digit'
                });
            } catch (error) {
                console.error('Error formatting timestamp:', timestamp, error);
                return typeof timestamp === 'string' ? timestamp : 'Error';
            }
        }

        // Show loading spinner inside a container
        function showLoading(container) {
            if (!container) {
                console.error("Attempted to show loading on null container");
                return;
            }
            if (container.id === 'accessTableBody') {
                // Either do nothing or just show empty table without spinner
                container.innerHTML = ``;
            } else {
                container.innerHTML = '<div class="loading"><div class="spinner"></div></div>';
            }
        }

        // Show empty state message inside a container
        function showEmptyState(container, message = "No data available") {
            if (!container) return;
            if (container.tagName === 'TBODY') {
                container.innerHTML = `<tr><td colspan="${container.previousElementSibling?.rows?.[0]?.cells?.length || 5}" class="empty-state">${message}</td></tr>`;
            } else {
                container.innerHTML = `<div class="empty-state">${message}</div>`;
            }
        }

        // Show error message inside a container
        function showErrorState(container, message = "Error loading data") {
            if (!container) return;
            if (container.tagName === 'TBODY') {
                container.innerHTML = `<tr><td colspan="${container.previousElementSibling?.rows?.[0]?.cells?.length || 5}" class="empty-state" style="color: var(--danger);">${message}</td></tr>`;
            } else {
                container.innerHTML = `<div class="empty-state" style="color: var(--danger);">${message}</div>`;
            }
        }

        // --- Log Management Functions ---

        // Request logs from server via WebSocket
        function requestLogs(offset, limit) {
            if (isLoadingMore) return;
            
            isLoadingMore = true;
            
            if (offset === 0) {
                showLoading(accessTableBody);
                allLogsLoaded = false;
                endOfLogs.style.display = 'none';
            } else {
                loadMoreSpinner.style.display = 'flex';
            }
            
            sendWebSocketMessage('4'+JSON.stringify({
                "type": "log",
                "offset": offset,
                "limit": limit
            }));
            
            logOffset = offset + limit;
        }

        // Render the access table with the current log data
        function renderAccessTable(isInitialLoad = false) {
            if (!logData || !Array.isArray(logData)) {
                console.error("Invalid log data:", logData);
                showEmptyState(accessTableBody, "Error loading logs.");
                return;
            }

            // Filter logs based on search input
            const searchTerm = searchInput.value.toLowerCase().trim();
            const filteredData = logData.filter(item => {
                if (!searchTerm) return true;
                const entityIdMatch = item.entityId && item.entityId.toLowerCase().includes(searchTerm);
                const descriptionMatch = item.description && item.description.toLowerCase().includes(searchTerm);
                return entityIdMatch || descriptionMatch;
            });

            // Sort logs (newest first)
            const sortedData = [...filteredData].sort((a, b) => {
                const dateA = a.timestamp ? new Date(a.timestamp) : null;
                const dateB = b.timestamp ? new Date(b.timestamp) : null;
                if (dateA && dateB && !isNaN(dateA) && !isNaN(dateB)) return dateB - dateA;
                else if (dateA && !isNaN(dateA)) return -1;
                else if (dateB && !isNaN(dateB)) return 1;
                else return 0;
            });

            // Clear table and render rows
            accessTableBody.innerHTML = '';

            if (sortedData.length === 0) {
                const message = searchTerm ? `No logs found matching "${searchInput.value}"` : "No client access logs found.";
                showEmptyState(accessTableBody, message);
            } else {
                sortedData.forEach(item => {
                    const row = document.createElement('tr');
                    let statusBadge = '-'; // Default status
                    if (item.actionType === 'INTERNET_ACCESS') {
                        if (item.blocked === true) statusBadge = '<span class="badge badge-blocked">Blocked</span>';
                        else if (item.blocked === false) statusBadge = '<span class="badge badge-allowed">Allowed</span>';
                    }
                    const displayEntityId = item.entityId ? (item.entityId.length > 15 ? item.entityId.substring(0, 10) + '...' : item.entityId) : '-';
                    const displayDescription = item.description || '-';

                    row.innerHTML = `
                        <td title="${item.entityId || ''}">${displayEntityId}</td>
                        <td>${item.actionType || '-'}</td>
                        <td title="${item.description || ''}">${displayDescription}</td>
                        <td class="timestamp">${formatTimestamp(item.timestamp)}</td>
                        <td>${statusBadge}</td>
                    `;
                    
                    // Add fade-in animation for new logs
                    if (!isInitialLoad && sortedData.indexOf(item) < 10) {
                        row.classList.add('fade-in');
                    }
                    
                    accessTableBody.appendChild(row);
                });
                
                // If this is the initial load, scroll to top
                if (isInitialLoad) {
                    accessTableContainer.scrollTop = 0;
                    userScrolled = false;
                    isAtBottom = true;
                }
            }
        }

        // Append older logs to the bottom of the table
        function appendOlderLogs(olderLogs) {
            if (!olderLogs || !Array.isArray(olderLogs) || olderLogs.length === 0) return;
            
            // Sort older logs (newest first)
            const sortedOlderLogs = [...olderLogs].sort((a, b) => {
                const dateA = a.timestamp ? new Date(a.timestamp) : null;
                const dateB = b.timestamp ? new Date(b.timestamp) : null;
                if (dateA && dateB && !isNaN(dateA) && !isNaN(dateB)) return dateB - dateA;
                else if (dateA && !isNaN(dateA)) return -1;
                else if (dateB && !isNaN(dateB)) return 1;
                else return 0;
            });
            
            // Filter based on search term
            const searchTerm = searchInput.value.toLowerCase().trim();
            const filteredOlderLogs = sortedOlderLogs.filter(item => {
                if (!searchTerm) return true;
                const entityIdMatch = item.entityId && item.entityId.toLowerCase().includes(searchTerm);
                const descriptionMatch = item.description && item.description.toLowerCase().includes(searchTerm);
                return entityIdMatch || descriptionMatch;
            });
            
            // Append each log to the table
            filteredOlderLogs.forEach(item => {
                const row = document.createElement('tr');
                let statusBadge = '-'; // Default status
                if (item.actionType === 'INTERNET_ACCESS') {
                    if (item.blocked === true) statusBadge = '<span class="badge badge-blocked">Blocked</span>';
                    else if (item.blocked === false) statusBadge = '<span class="badge badge-allowed">Allowed</span>';
                }
                const displayEntityId = item.entityId ? (item.entityId.length > 15 ? item.entityId.substring(0, 10) + '...' : item.entityId) : '-';
                const displayDescription = item.description || '-';

                row.innerHTML = `
                    <td title="${item.entityId || ''}">${displayEntityId}</td>
                    <td>${item.actionType || '-'}</td>
                    <td title="${item.description || ''}">${displayDescription}</td>
                    <td class="timestamp">${formatTimestamp(item.timestamp)}</td>
                    <td>${statusBadge}</td>
                `;
                accessTableBody.appendChild(row);
            });
        }

        // Handle live log updates from WebSocket
        function handleLiveLogUpdates(newLogs) {
            // sendWebSocketMessage(`4 begin func: ${newLogs}`)
            if (!newLogs) return;
            
            // sendWebSocketMessage('4 appending to arr')
            // Add new logs to the beginning of the array
            logData = [newLogs, ...logData];
            
            // sendWebSocketMessage('4 checking and rendering')
            // If user is at the bottom or hasn't scrolled, update the view
            // if (isAtBottom && !userScrolled) {
            renderAccessTable();
            // sendWebSocketMessage('4 done rendering')
            // } else {
            //     // Show notification that new logs are available
            //     hasNewLogs = true;
            //     newLogsIndicator.style.display = 'block';
            // }
        }

        // Scroll to top to see new logs
        function scrollToTop() {
            accessTableContainer.scrollTop = 0;
            newLogsIndicator.style.display = 'none';
            hasNewLogs = false;
            renderAccessTable();
        }

        // Check if user has scrolled to bottom to load more logs
        function checkScrollPosition() {
            const { scrollTop, scrollHeight, clientHeight } = accessTableContainer;
            
            // Check if user is at the bottom
            isAtBottom = Math.abs(scrollHeight - scrollTop - clientHeight) < 5;
            
            // If user scrolled to bottom and we have more logs to load
            if (isAtBottom && !isLoadingMore && !allLogsLoaded) {
                requestLogs(logOffset+liveUpdated, logBatchSize);
                liveUpdated=0;
            }
            
            // If user scrolled back to top, hide new logs indicator
            if (scrollTop < 50 && hasNewLogs) {
                newLogsIndicator.style.display = 'none';
                hasNewLogs = false;
            }
        }

        // --- Render Functions for Blacklist/Whitelist ---

        // Render blacklist domains and keywords
        function renderBlacklist() {
            // Domains
            const domains = blacklistSettings?.data?.domains || [];
            if (domains.length === 0) { showEmptyState(domainsContainer, "No blacklisted domains"); }
            else {
                domainsContainer.innerHTML = '';
                domains.forEach(domain => {
                    const item = document.createElement('div'); item.className = 'url-item';
                    item.innerHTML = `<span>${domain}</span><button class="remove-btn" data-value="${domain}" data-type="domain" title="Remove domain">Remove</button>`;
                    item.querySelector('.remove-btn').addEventListener('click', handleRemoveFromBlacklist);
                    domainsContainer.appendChild(item);
                });
            }
            // Keywords
            const keywords = blacklistSettings?.data?.keywords || [];
            if (keywords.length === 0) { showEmptyState(keywordsContainer, "No blacklisted keywords"); }
            else {
                keywordsContainer.innerHTML = '';
                keywords.forEach(keyword => {
                    const item = document.createElement('div'); item.className = 'url-item';
                    item.innerHTML = `<span>${keyword}</span><button class="remove-btn" data-value="${keyword}" data-type="keyword" title="Remove keyword">Remove</button>`;
                    item.querySelector('.remove-btn').addEventListener('click', handleRemoveFromBlacklist);
                    keywordsContainer.appendChild(item);
                });
            }
            // Timestamp
            blacklistLastUpdatedElement.textContent = blacklistSettings?.data?.lastUpdated ? `Last updated: ${formatTimestamp(blacklistSettings.data.lastUpdated)}` : 'Last updated: N/A';
        }

        // Render whitelist
        function renderWhitelist() {
            if (whitelistUrls.length === 0) { showEmptyState(whitelistContainer, "No whitelisted websites"); }
            else {
                whitelistContainer.innerHTML = '';
                whitelistUrls.forEach(url => {
                    const item = document.createElement('div'); item.className = 'url-item';
                    item.innerHTML = `<span>${url}</span><button class="remove-btn" data-value="${url}" data-list="whitelist" title="Remove URL">Remove</button>`;
                    item.querySelector('.remove-btn').addEventListener('click', handleRemoveFromWhitelist);
                    whitelistContainer.appendChild(item);
                });
            }
            // Timestamp (Example: Show last render time, ideally fetch from backend setting)
            whitelistLastUpdatedElement.textContent = `List updated: ${formatTimestamp(new Date())}`;
        }

        // --- Update Functions (Interacting with Backend) ---

        // Generic function to update settings on the server
        async function updateSettings(settingsObject) {
            console.log("Attempting to update settings:", settingsObject);
            try {
                // Basic check - needs ID for update, unless backend handles creation by type
                if (!settingsObject || (!settingsObject.id && !settingsObject.type)) {
                    console.error("Update attempted without ID or Type:", settingsObject);
                    throw new Error("Cannot update setting without identifier (ID or Type).");
                }
                
                // Use WebSocket instead of fetch
                const success = sendWebSocketMessage('4'+JSON.stringify({
                    "type": "update_settings",
                    "settings": settingsObject
                }));
                
                if (!success) {
                    throw new Error("Failed to send settings update via WebSocket");
                }
                
                return settingsObject; // Return the object for optimistic updates
            } catch (error) {
                console.error('Error updating settings:', error);
                alert(`Error saving settings: ${error.message}`);
                throw error; // Re-throw for calling function
            }
        }

        // --- Event Handlers for Lists ---

        // Add domain to blacklist
        async function handleAddDomain() {
            const domain = domainInput.value.trim().toLowerCase();
            if (!domain) return;
            if (!blacklistSettings?.data) { alert('Blacklist settings not loaded.'); return; }
            if (blacklistSettings.data.domains.includes(domain)) { alert('Domain already blacklisted.'); return; }

            const originalDomains = [...blacklistSettings.data.domains];
            blacklistSettings.data.domains.push(domain); // Optimistic update
            renderBlacklist(); domainInput.value = '';

            try {
                showLoading(domainsContainer);
                blacklistSettings.data.lastUpdated = new Date().toISOString();
                const updated = await updateSettings(blacklistSettings);
                blacklistSettings = updated; // Use response from server
                renderBlacklist();
            } catch (error) {
                blacklistSettings.data.domains = originalDomains; renderBlacklist(); // Rollback
            }
        }

        // Add keyword to blacklist
        async function handleAddKeyword() {
            const keyword = keywordInput.value.trim().toLowerCase();
            if (!keyword) return;
            if (!blacklistSettings?.data) { alert('Blacklist settings not loaded.'); return; }
            if (blacklistSettings.data.keywords.includes(keyword)) { alert('Keyword already blacklisted.'); return; }

            const originalKeywords = [...blacklistSettings.data.keywords];
            blacklistSettings.data.keywords.push(keyword); // Optimistic update
            renderBlacklist(); keywordInput.value = '';

            try {
                showLoading(keywordsContainer);
                blacklistSettings.data.lastUpdated = new Date().toISOString();
                const updated = await updateSettings(blacklistSettings);
                blacklistSettings = updated;
                renderBlacklist();
            } catch (error) {
                blacklistSettings.data.keywords = originalKeywords; renderBlacklist(); // Rollback
            }
        }

        // Add URL to whitelist
        async function handleAddToWhitelist() {
            const url = whitelistInput.value.trim();
            if (!url) return;
            if (whitelistUrls.includes(url)) { alert('URL already whitelisted.'); return; }

            // Check blacklist conflict
            if (blacklistSettings?.data?.domains.includes(url)) {
                if (confirm(`"${url}" is blacklisted. Remove from blacklist and add to whitelist?`)) {
                    try { await handleRemoveFromBlacklist({ target: { dataset: { value: url, type: 'domain' } } }, true); } // true = skip confirm
                    catch (error) { alert(`Could not remove "${url}" from blacklist. Aborting add to whitelist.`); return; }
                } else { return; } // User cancelled blacklist removal
            }

            // Find or prepare the whitelist setting object for update
            let whitelistSetting = { type: 'WHITELIST', data: { urls: [...whitelistUrls], lastUpdated: null } };
            
            const originalWhitelist = [...whitelistUrls];
            whitelistUrls.push(url); // Optimistic UI update
            whitelistSetting.data.urls.push(url); // Update object to be sent
            renderWhitelist(); whitelistInput.value = '';

            try {
                showLoading(whitelistContainer);
                whitelistSetting.data.lastUpdated = new Date().toISOString();
                await updateSettings(whitelistSetting);
                renderWhitelist();
            } catch (error) {
                whitelistUrls = originalWhitelist; // Rollback global state
                renderWhitelist(); // Rollback UI
            }
        }

        // Remove item from blacklist
        async function handleRemoveFromBlacklist(event, skipConfirm = false) {
            const value = event.target.dataset.value; const type = event.target.dataset.type;
            if (!value || !type || !blacklistSettings?.data) return;
            if (!skipConfirm && !confirm(`Remove "${value}" (${type}) from blacklist?`)) return;

            let originalItems, targetContainer;
            if (type === 'domain') { originalItems = [...blacklistSettings.data.domains]; blacklistSettings.data.domains = blacklistSettings.data.domains.filter(d => d !== value); targetContainer = domainsContainer; }
            else if (type === 'keyword') { originalItems = [...blacklistSettings.data.keywords]; blacklistSettings.data.keywords = blacklistSettings.data.keywords.filter(k => k !== value); targetContainer = keywordsContainer; }
            else return;

            renderBlacklist(); // Optimistic UI update

            try {
                showLoading(targetContainer);
                blacklistSettings.data.lastUpdated = new Date().toISOString();
                const updated = await updateSettings(blacklistSettings);
                blacklistSettings = updated; renderBlacklist();
            } catch (error) {
                if (type === 'domain') blacklistSettings.data.domains = originalItems;
                if (type === 'keyword') blacklistSettings.data.keywords = originalItems;
                renderBlacklist(); // Rollback UI
                throw error; // Re-throw for handleAddToWhitelist conflict resolution
            }
        }

        // Remove URL from whitelist
        async function handleRemoveFromWhitelist(event) {
            const url = event.target.dataset.value;
            if (!url || !confirm(`Remove "${url}" from whitelist?`)) return;

            let whitelistSetting = { type: 'WHITELIST', data: { urls: [...whitelistUrls], lastUpdated: null } };
            
            const originalWhitelist = [...whitelistUrls];
            whitelistUrls = whitelistUrls.filter(item => item !== url); // Optimistic UI
            whitelistSetting.data.urls = whitelistSetting.data.urls.filter(item => item !== url); // Update object
            renderWhitelist();

            try {
                showLoading(whitelistContainer);
                whitelistSetting.data.lastUpdated = new Date().toISOString();
                await updateSettings(whitelistSetting);
                renderWhitelist();
            } catch (error) {
                whitelistUrls = originalWhitelist;
                renderWhitelist(); // Rollback
            }
        }

        // Handle tab switching in blacklist card
        function switchTab(event) {
            const clickedTab = event.target;
            if (!clickedTab.classList.contains('tab')) return;
            const tabId = clickedTab.dataset.tab; if (!tabId) return;
            const parentCard = clickedTab.closest('.list-card'); if (!parentCard) return;
            parentCard.querySelectorAll('.tab').forEach(tab => tab.classList.toggle('active', tab === clickedTab));
            parentCard.querySelectorAll('.tab-content').forEach(content => content.classList.toggle('active', content.id === `${tabId}-content`));
        }

        // --- Initialization ---
        function init() {
            // Set up scroll event listener for infinite scrolling
            accessTableContainer.addEventListener('scroll', () => {
                userScrolled = true;
                checkScrollPosition();
            });

            // New logs indicator click handler
            newLogsIndicator.addEventListener('click', scrollToTop);

            // Search listener - Reset and re-render table
            searchInput.addEventListener('input', () => {
                renderAccessTable(true);
            });

            // Refresh button
            refreshBtn.addEventListener('click', () => {
                logOffset = 0;
                allLogsLoaded = false;
                endOfLogs.style.display = 'none';
                requestLogs(0, logBatchSize);
            });

            // Blacklist listeners
            addToDomainsBtn.addEventListener('click', handleAddDomain);
            addToKeywordsBtn.addEventListener('click', handleAddKeyword);
            domainInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleAddDomain(); });
            keywordInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleAddKeyword(); });

            // Whitelist listeners
            addToWhitelistBtn.addEventListener('click', handleAddToWhitelist);
            whitelistInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleAddToWhitelist(); });

            // Tab switching listener (delegated)
            document.querySelector('.list-card.blacklist')?.addEventListener('click', switchTab);

            console.log("Website Access Monitor Initialized");
        }

        // Start the application when the DOM is ready
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>

</html>